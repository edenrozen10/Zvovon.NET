

שלב  2- ארכיטקטורה:

שאלה מספר 4:
העיקרון של ארכיטקטורת microservices  על בסיס k8s הוא ליצור מאגר של שרתים שבכל שרת רצים רכיבים עצמאים, שכל אחד מהם אחראי על חלק כלשהו במערכת ובנוי מרכיבים קטנים יותר המבצעים פעולות בסיסיות בו"ז.
 הקשר בין רכיב לרכיב הוא מינימלי. למערכת יש יכולות לשכפל את הרכיבים העצמאיים במידת הצורך כתלות בעומס על המערכת, ולהזיזם משרת לשרת. בנוסף יש רכיב שבודק שהכל כשורה, מה צריך לתקן ובאיזה שרת.
המטרה היא לאפשר שימוש נרחב, מהיר ויעיל יותר במערכת, שמתאפשר בזכות הדינאמיות שמתקיימת במערכת.
מערכת המחשבון הפיזיקלי צריכה להוציא שלושה פלטים (חישובים). אלו שלושת משימותיה העיקריות, לכל משימה יצרתי פונקציה.
כל חישוב עיקרי בנוי מחישובי עזר של פרמטרים אחרים. ולכן, כיוון שהמטרה היא לפרק את משימות המערכת עד כדי משימה מינמלית, יצרתי פונקציה גם לכל חישוב עזר.
כמו כן ישנה פונקציה שתפקידה העיקרי הוא לבדוק שהכל רץ כשורה, כלומר במקרה שלנו, שהקלט שנכנס הוא תקין.
כלומר אם נקביל את זה לארכיטקטורה של microservices, הפונקציות של החישובים העיקריים הן הרכיבים העצמאיים, והפונקציות של חישובי העזר הן הרכיבים הקטנים שמבצעים פעולות בסיסיות.
דיאגרמה שמראה את מעבר המידע במערכת של microservices:
(נמצאת בקובץ נפרד 1jpg)

במקרה של k8s הדיאגרמה תראה בערך כך:
(נמצאת בקובץ נפרד 2jpg)
כאשר במערכת גדולה יש n יחידות כמו הדיאגרמה הזו. המשולשים האפורים מכילים את כל השרשרת שהוצגה בדיאגרמה הקודמת (יש רק שלושה כי לא נכנסו עוד בדיאגרמה שלי אך יכולים להיות רבים יותר).

שאלה מספר 5: 
כתבתי את צד השרת בעזרת php ואת צד הלקוח בעזרת HTML.
קוד הHTML וקוד הphp נמצאים בRepo. מצרפת את הכתובת של ה"אתר" (מקווה שיעבוד כי הדומיין הזה נוטה לקרוס:/ ): http://192.168.1.19/ZVOV/   (נעזרתי בתוכנת XAMPP).


שאלה מספר 6:
במקרה של בקשה  לא צפויה, כלומר בקשה שהמערכת לא יודעת להתמודד איתה (תו במקום מספר, מספר ממש ממש גדול) המערכת תוציא הודעת שגיאה (בהתאם לפרוטוקול http זו תהיה הודעה מסוג 4xx). המערכת תרוקן את הערך שנקלט (כפי שהוסבר בשלב אחד, על מנת שהbuffer יהיה ריק) והמשתמש יוכל להגיש בקשה חדשה.

שאלה מספר 7: 
בגלל שזו מערכת מסווגת, ואנו רוצים להגן כמה שיותר על המידע שעובר בה, נשתמש בשני אמצעי זהירות:
1- בעת קידוד צד השרת נבחר בבקשה מסוג POST ולא GET, שכן בבקשת GET הפרטים שמכניס המשתמש מופיעים בURL, מה שאומר שהם חשופים, לעומת בבקשת POST בה הפרטים שמכניס המשתמש נשארים בBODY. בנוסף לבקשת GET אבל לעשות זיכרון קאשינג, משמע הפרטים ישמרו, ולבקשת POST אי אפשר. ולכן בקשת POST 
אמינה ובטוחה יותר.

2- אפשר להעביר את השימוש במערכת להיות על שכבת SSL/TLS , ובכך תתווסף שכבת הגנה לפרוטוקול http (בעצם נעבור לפרוטוקול (https.


שאלה מספר 8: 
בעיקרון, עבור מערכות שמתבססות על תקשורת http, אפשר להשתמש במטמון שמנוהל ע"י הפרוטוקול. ניהול המטמון בhttp מחולק למנגנון אימות ומנגנון תפוגה.
מנגנון האימות מבוסס על המידע שנשלח עם כל עמוד. כלומר במקרה שלנו המידע שהכניס המשתמש.
מנגנון התפוגה הוא תאריך תפוגה שמוצמד לכל עמוד ע"י השרת. התאריך בעצם אומר עד תאריך X אפשר להשתמש בעמוד ללא תקשורת עם השרת, ללא רפרש.

כלומר המידע שהוכנס ע"י משתמשים וחושב ישמר במסד הנתונים. ולכן במקרה שיבקשו שוב את אותו החישוב שוב, יוכל השרת ל"שלוף" את התוצאה ולחסוך בתהליכים.

אבל בשאלה 7 אמרנו שאם אנחנו רוצים לשמור על המידע שלנו, עלינו להשתמש בבקשת POST  אשר לא מאפשרת cache .

ולכן בשביל גם לשמור על המידע וגם לאפשר שימוש במידע המוטמן על מנת לייעל את המערכת, נצטרך לוותר קצת על הסיווג וקצת על הייעול.

נוכל להשתמש בבקשת GET  אך נקבע את תאריך התפוגה לזמן קצר יחסית, נניח יממה
 כך שאחרי יממה המידע ימחק מהמטמון, אבל עד אז שרת האחסון יזכור את התוצאות שכבר התקבלו עבור נתונים כלשהם ויוכל לשחזר במקרה שיתקבלו נתונים זהים באותו פרק זמן.




שאלה מספר 9:
אם המערכת באמת תהיה בנויה כקוברנטיס, נוכל לשכפל את הפודים לפי הצורך, ובמקרה ששרת אחד עמוס מדי, נוכל להעביר לשרת אחר.
